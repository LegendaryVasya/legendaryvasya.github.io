---
title: "Отравление веб-кэша (теория)"
layout: post
date: 2025-05-14 00:00:00 +0100
---
Отравление веб-кэша - это вектор атаки на бековый компонент между конечным сервером и пользовательской стороной(фронтендом), который занимается снижением нагрузки с основого сервера за счет прихранивания контента на своей стороне, если клиент запрашивает ресурс, который не хранится в веб-кэше, ресурс будет запрошен с веб-сервера. Затем веб-кэш сохраняет ресурс локально и, таким образом, может отвечать на любые будущие запросы этого ресурса, не запрашивая его с веб-сервера. Веб-кеш может быть реализован как программно, так и программно аппаратно.
#### Как работают веб-кэши?
Как обсуждалось выше, веб-кэши хранят ресурсы для снижения нагрузки на веб-сервер. Это могут быть статические ресурсы, такие как таблицы стилей или файлы скриптов, а также динамические ответы, генерируемые веб-сервером на основе предоставленных пользователем данных, таких как поисковые запросы. Для обслуживания кэшированных ресурсов веб-кэш должен иметь возможность различать запросы, чтобы определить, могут ли два запроса обслуживаться одним и тем же кэшированным ответом или необходимо получить новый ответ с веб-сервера.

Веб-кэши используют только подмножество всех параметров запроса, чтобы определить, следует ли обслуживать два запроса одним и тем же ответом. Это подмножество называется `Cache Key`. В большинстве конфигураций по умолчанию это включает `url path`, `query parameters`  и `Host` заголовок. Однако ключи кэша можно настроить индивидуально, чтобы включить или исключить любые компоненты HTTP запроса, для  эффективной работы для конкретного веб-приложения.

В рамках веб-кеша составляющие http запроса разделяют на `keyed` и `unkeyed` параметры. . Все параметры, которые являются частью ключа кэша, называются `keyed`, в то время как все остальные параметры называются `unkeyed`, где `unkeyed` все что не учитывается при выдачи кеша.

```
http {
  proxy_cache_path /cache levels=1:2 keys_zone=STATIC:10m inactive=24h max_size=1g;

  server {
    listen       80;

    location / {
      proxy_pass             http://172.10.0.1:80;
      proxy_buffering        on;
      proxy_cache            STATIC;
      proxy_cache_valid      2m;
      proxy_cache_key $scheme$proxy_host$uri$args;
      add_header X-MIEM-Status $upstream_cache_status;
    }
  }
}
```

Где: 
- `proxy_cache_path`устанавливает общие параметры кэша, такие как место хранения
- `proxy_pass`устанавливает местоположение веб-сервера
- `proxy_buffering`включает кэширование
- `proxy_cache`задает имя кэша (как определено в `proxy_cache_path`)
- `proxy_cache_valid`устанавливает время, по истечении которого кэш истекает
- `proxy_cache_key`определяет ключ кэша
- `add_header`добавляет заголовок к ответам через который на фронт будет передан статус доступности кеша. Статус может быть: `MISS`, `BYPASS`, `EXPIRED`, `STALE`, `UPDATING`, `REVALIDATED`, или `HIT`.

Ключ кэша можно настроить так, чтобы он включал только определенные параметры GET, изменив конфигурацию следующим образом

```
proxy_cache_key $scheme$proxy_host$uri$arg_example;
```

#### Атаки отравления веб-кэша

Обобщу в чем критичность. Если у злоумышленника получится внести изменения в кеш веб ресурса, то при обращению к веб ресурсу все пользователи с ключами для которых был модифицирован кеш, получат полезную нагрузку злоумышленника или состояние ресурса в момент его изменения злоумышленником.

##### XSS

Один из побочных и безобидных явлений отравления кеша является отражение данных. Но в случае если данные сохранятся как элемент DOM страницы, то это может привести к эксплуатации межсайтового сериптинга(XSS).

##### Unkeyed Cookies

 Если веб-приложение использует пользовательский файл cookie для запоминания определенных выборов пользователя, и этот файл cookie не ключевой, его можно использовать для отравления кэша, как пример A/B тесты - возможность сохранить в контент сраницы сегмента полезную нагрузку, которая отобразится пользователям которые попадут на этот же сегмент.
##### Отказ в обслуживании

Я знаю как минимум два сценария как возможно реализовать отказ в обслуживании посредством отравления кеша.

В первом варианте логика кеширования включает заголовок хоста в свой ключ кэша **но не включает порт**. Затем веб-приложение использует заголовок хоста для построения абсолютного URL для перенаправления:

```
HTTP/1.1 302 Found
Location: https://example.com:443/
```

Соответсвено мы можем получить DoS, отправив запрос:

```
GET / HTTP/1.1
Host: example.com:22280
```

Так как оригинальное приложение работает на порту 443

Второй вариант связан с изменением выдачи контента главным веб-приложением и сохранением этого состояния в кеш. Такой вектор можно отнести к CVE. Хорошим примером будет дырявый фреймворк Next.js, где используя комбинацию "внутренних" заголовков можно влиять на ответы от главного веб-приложения. Например добавление в запрос заголовка `x-middleware-prefetch: 1` приводит к пустому объекту JSON `{}`в качестве ответа. Если присутствует CDN или система кэширования, этот пустой ответ может быть потенциально кэширован — в зависимости от конфигурации правил кэширования — делая целевую страницу непрактичной, а ее содержимое недоступным . Использование `x-invoke-status` возможно переопределять кода состояния. Например указав любой HTTP-код для изменения кода ответа и запросить страницу с ошибкой ( типа /error). Обычно CDN и системы кэширования настроены так, чтобы не кэшировать коды ошибок HTTP. Однако злоумышленник может указать код 200 для соответствия правилам кэширования и эффективно «принудительно» кэшировать страницу с ошибкой.

Также в зависимости от квери-параметра `__nextDataReq` или заголовка `x-nextjs-data:1` и заголовка `x-now-route-matches` возможно закешировать для любой страницы ответ с содержанием объекта фреймворка `pageProps`.

Все выше описанные способы для фреймворка возможны только при соблюдении определенных условий, наприме таких как версия ПО и его конфигурация.

У zhero-web-sec есть серия качественных и глубоких статей по анализу CVE Nextjs. Рекомендую ознакомиться.

При атаках на отравление кеша важно учитывать "приватизацию" при создания PoC и формировании полезной нагрузки, т.е если много пользователей используют веб-сайт, маловероятно, что кэш будет пустым, когда мы отправим нашу вредоносную полезную нагрузку, то есть нам будет предоставлен уже кэшированный ответ, и наш запрос никогда не попадет на веб-сервер.

Можно попробовать использовать в нашем запросе заголовки:
```
 Cache-Control: no-cache
 или
 Pragma: no-cache
```
Для отправки запроса на целевой веб-сервер даже если есть кэшированная запись с тем же ключом кэша.
Однако эти заголовки нельзя использовать для принудительного обновления кэшем веб-страниц.

Для гарантии того, чтобы "отравленный" запрос не попал никаким другим пользователям, пока мы не закончим можно использователь технику `cache buster`. Сache buster - это уникальное значение параметра в ключе кеша. Поскольку у нас есть уникальный ключ кэша, только мы получаем отравленный ответ, и ни один реальный пользователь не затрагивается. Имейте в виду, что придется использовать другой кэш-бастер в последующем запросе.

#### Продвинутые методы отравления веб-кэша

##### Использование тела в GET запросе

В соответсвии с RFC 7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content любой HTTP-запрос может содержать тело запроса, независимо от метода.

*Тезис в рамках GET:*
```
A payload within a GET request message has no defined semantics;
sending a payload body on a GET request might cause some existing implementations to reject the request.
```
 Eсли веб-сервер неправильно настроен или реализован, он может анализировать параметры из тела запроса GET, что может привести к атакам с отравлением веб-кэша.

##### Parameter Cloaking

Цель состоит в том, чтобы создать несоответствие между веб-сервером и веб-кэшем таким образом, чтобы веб-кэш использовал другой параметр для ключа кэша, чем тот, который веб-сервер использует для обслуживания ответа.

В качестве примера можно рассмотреть CVE-2020-28473 веб-фреймворка Bottle. Bottle допускает использование точки с запятой для разделения различных параметров URL `/test?a=1;b=2`, в то время как для кеширующего посредника этот же запрос будет выглядеть как параметр `a` c значением `1;b=2`. Это может привести к тому, что вредоносные запросы будут кэшироваться как полностью безопасные, так как прокси обычно не видит точку с запятой как разделитель и, следовательно, не будет включать ее в ключ кэша неключевого параметра.

#### Митигация

Предотвращение уязвимостей отравления веб-кэша является непростой задачей. В некоторых случаях разработчики бэкенда могут не знать, что перед веб-сервером находится веб-кэш. Кроме того, администраторы, настраивающие веб-кэш и ключ кэша, могут быть разными людьми, чем разработчики бэкенда. Это может привести к появлению скрытых неключевых параметров, которые веб-приложение использует для изменения ответа.

Правильная настройка веб-кэша во многом зависит от веб-сервера и веб-приложения, с которыми он сочетается. Таким образом, нам необходимо обеспечить следующее:

- Не используйте конфигурацию веб-кэша по умолчанию. Настройте веб-кэш в соответствии с потребностями веб-приложения
- Убедиться что веб-сервер не поддерживает обработку тела GET запросе
- Убедиться что параметр запроса, который каким-либо образом влияет на ответ - keyed
- Убедиться что у вас актуальная версия ПО
- Убедиться что у приложения отсуствуют язвимости стороны пользователя, такие как XSS, чтобы в случае возникновения отравления кеша убрать дальнейшую эскалацию.
